name: Deploy ChopperTracker

on:
  push:
    branches:
      - main
  workflow_dispatch:

env:
  AWS_REGION: us-east-1
  AWS_ACCOUNT_ID: 038342322731

jobs:
  deploy:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
    
    - name: Verify AWS Account
      run: |
        echo "Current AWS Account:"
        aws sts get-caller-identity
        echo "Expected Account ID: $AWS_ACCOUNT_ID"
        CURRENT_ACCOUNT=$(aws sts get-caller-identity --query Account --output text)
        echo "Current Account ID: $CURRENT_ACCOUNT"
        echo "âœ“ Confirmed deployment to ChopperTracker sub-account ($CURRENT_ACCOUNT)"

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        
    - name: Install frontend dependencies
      working-directory: ./FrontEnd
      run: npm ci

    - name: Build frontend
      working-directory: ./FrontEnd
      env:
        VITE_API_BASE_URL: https://api.choppertracker.com
      run: npm run build

    - name: Deploy frontend to S3
      run: |
        # Use existing S3 bucket
        BUCKET_NAME="flight-tracker-web-ui-1750266711"
        echo "Using existing S3 bucket: $BUCKET_NAME"
        
        # Upload files to existing bucket
        aws s3 sync ./FrontEnd/dist s3://$BUCKET_NAME \
          --delete \
          --acl public-read \
          --cache-control "public, max-age=3600"

    - name: Setup Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.9'

    - name: Install backend dependencies
      run: |
        cd BackEnd
        python -m pip install --upgrade pip
        pip install -r requirements.txt

    - name: Deploy ECS Fargate Infrastructure
      run: |
        # Use existing default VPC to avoid VPC limits
        echo "Using existing default VPC..."
        VPC_ID=$(aws ec2 describe-vpcs --filters "Name=is-default,Values=true" --query 'Vpcs[0].VpcId' --output text)
        
        # Get existing subnets in default VPC
        SUBNET1_ID=$(aws ec2 describe-subnets --filters "Name=vpc-id,Values=$VPC_ID" "Name=availability-zone,Values=us-east-1a" --query 'Subnets[0].SubnetId' --output text)
        SUBNET2_ID=$(aws ec2 describe-subnets --filters "Name=vpc-id,Values=$VPC_ID" "Name=availability-zone,Values=us-east-1b" --query 'Subnets[0].SubnetId' --output text)
        
        # Fallback to any available subnets if specific AZs not found
        if [ "$SUBNET1_ID" = "None" ] || [ "$SUBNET2_ID" = "None" ]; then
          echo "Using any available subnets in default VPC..."
          SUBNETS=($(aws ec2 describe-subnets --filters "Name=vpc-id,Values=$VPC_ID" --query 'Subnets[].SubnetId' --output text))
          SUBNET1_ID=${SUBNETS[0]}
          SUBNET2_ID=${SUBNETS[1]:-${SUBNETS[0]}}
        fi
        
        echo "Using VPC: $VPC_ID"
        echo "Using Subnets: $SUBNET1_ID, $SUBNET2_ID"
        
        # Use existing security groups
        ALB_SG_ID=$(aws ec2 describe-security-groups --filters "Name=group-name,Values=flight-tracker-alb-sg" "Name=vpc-id,Values=$VPC_ID" --query 'SecurityGroups[0].GroupId' --output text)
        ECS_SG_ID=$(aws ec2 describe-security-groups --filters "Name=group-name,Values=flight-tracker-ecs-sg" "Name=vpc-id,Values=$VPC_ID" --query 'SecurityGroups[0].GroupId' --output text)
        REDIS_SG_ID=$(aws ec2 describe-security-groups --filters "Name=group-name,Values=flight-tracker-redis-sg" "Name=vpc-id,Values=$VPC_ID" --query 'SecurityGroups[0].GroupId' --output text)
        
        # ALB security group rules (HTTP/HTTPS from anywhere) - ignore if rules already exist
        aws ec2 authorize-security-group-ingress --group-id $ALB_SG_ID --protocol tcp --port 80 --cidr 0.0.0.0/0 || echo "Port 80 rule may already exist"
        aws ec2 authorize-security-group-ingress --group-id $ALB_SG_ID --protocol tcp --port 443 --cidr 0.0.0.0/0 || echo "Port 443 rule may already exist"
        
        # ECS security group rules (from ALB only) - ignore if rules already exist
        aws ec2 authorize-security-group-ingress --group-id $ECS_SG_ID --protocol tcp --port 80 --source-group $ALB_SG_ID || echo "ECS port 80 rule may already exist"
        
        # Redis security group rules (from ECS only) - ignore if rules already exist
        aws ec2 authorize-security-group-ingress --group-id $REDIS_SG_ID --protocol tcp --port 6379 --source-group $ECS_SG_ID || echo "Redis port 6379 rule may already exist"
        
        echo "VPC_ID=$VPC_ID" >> deployment_vars.env
        echo "SUBNET1_ID=$SUBNET1_ID" >> deployment_vars.env
        echo "SUBNET2_ID=$SUBNET2_ID" >> deployment_vars.env
        echo "ALB_SG_ID=$ALB_SG_ID" >> deployment_vars.env
        echo "ECS_SG_ID=$ECS_SG_ID" >> deployment_vars.env
        echo "REDIS_SG_ID=$REDIS_SG_ID" >> deployment_vars.env

    - name: Skip ElastiCache Redis (Permissions Issue)
      run: |
        source deployment_vars.env
        
        # Skip Redis for now due to IAM permissions
        # The application can fall back to in-memory storage
        echo "REDIS_ENDPOINT=localhost" >> deployment_vars.env
        echo "Skipping Redis creation due to IAM permissions - using in-memory fallback"

    - name: Build and Push Docker Image
      run: |
        # Get ECR login token
        aws ecr get-login-password --region $AWS_REGION | docker login --username AWS --password-stdin 958933162000.dkr.ecr.us-east-1.amazonaws.com
        
        # Build Docker image with current commit hash
        cd BackEnd
        COMMIT_HASH=$(git rev-parse --short HEAD)
        ECR_URI="958933162000.dkr.ecr.us-east-1.amazonaws.com/flight-tracker-backend"
        
        docker build \
          --build-arg COMMIT_HASH=$COMMIT_HASH \
          --build-arg BUILD_TIME=$(date -u +"%Y-%m-%dT%H:%M:%SZ") \
          -t $ECR_URI:latest \
          -t $ECR_URI:$COMMIT_HASH \
          .
        
        # Push to ECR
        docker push $ECR_URI:latest
        docker push $ECR_URI:$COMMIT_HASH
        
        echo "ECR_IMAGE_URI=$ECR_URI:latest" >> ../deployment_vars.env
        echo "Built and pushed image: $ECR_URI:$COMMIT_HASH"

    - name: Deploy Application Load Balancer
      run: |
        source deployment_vars.env
        
        # Use existing ALB
        ALB_ARN=$(aws elbv2 describe-load-balancers --names flight-tracker-alb --query 'LoadBalancers[0].LoadBalancerArn' --output text)
        
        if [ "$ALB_ARN" = "None" ]; then
          # Create Application Load Balancer
          ALB_ARN=$(aws elbv2 create-load-balancer \
            --name choppertracker-alb \
            --subnets $SUBNET1_ID $SUBNET2_ID \
            --security-groups $ALB_SG_ID \
            --scheme internet-facing \
            --type application \
            --ip-address-type ipv4 \
            --query 'LoadBalancers[0].LoadBalancerArn' --output text)
          echo "Created new ALB: $ALB_ARN"
        else
          echo "Using existing ALB: $ALB_ARN"
        fi
        
        # Get ALB DNS name
        ALB_DNS=$(aws elbv2 describe-load-balancers --load-balancer-arns $ALB_ARN --query 'LoadBalancers[0].DNSName' --output text)
        
        # Use existing target group
        TARGET_GROUP_ARN=$(aws elbv2 describe-target-groups --names flight-tracker-tg --query 'TargetGroups[0].TargetGroupArn' --output text)
        
        if [ "$TARGET_GROUP_ARN" = "None" ]; then
          # Create target group
          TARGET_GROUP_ARN=$(aws elbv2 create-target-group \
            --name choppertracker-tg \
            --protocol HTTP \
            --port 80 \
            --vpc-id $VPC_ID \
            --target-type ip \
            --health-check-path / \
            --health-check-interval-seconds 30 \
            --healthy-threshold-count 2 \
            --unhealthy-threshold-count 5 \
            --query 'TargetGroups[0].TargetGroupArn' --output text)
          echo "Created new target group: $TARGET_GROUP_ARN"
        else
          echo "Using existing target group: $TARGET_GROUP_ARN"
        fi
        
        # Create HTTP listener if it doesn't exist
        LISTENER_ARN=$(aws elbv2 describe-listeners --load-balancer-arn $ALB_ARN --query 'Listeners[?Port==`80`].ListenerArn' --output text 2>/dev/null || echo "None")
        
        if [ "$LISTENER_ARN" = "None" ] || [ -z "$LISTENER_ARN" ]; then
          echo "Creating HTTP listener..."
          aws elbv2 create-listener \
            --load-balancer-arn $ALB_ARN \
            --protocol HTTP \
            --port 80 \
            --default-actions Type=forward,TargetGroupArn=$TARGET_GROUP_ARN
        else
          echo "HTTP listener already exists: $LISTENER_ARN"
        fi
        
        echo "ALB_ARN=$ALB_ARN" >> deployment_vars.env
        echo "ALB_DNS=$ALB_DNS" >> deployment_vars.env
        echo "TARGET_GROUP_ARN=$TARGET_GROUP_ARN" >> deployment_vars.env
        echo "Application Load Balancer created: $ALB_DNS"

    - name: Deploy ECS Cluster and Service
      run: |
        source deployment_vars.env
        
        # Ensure service-linked roles exist (check first, then create if needed)
        if ! aws iam get-role --role-name AWSServiceRoleForECS >/dev/null 2>&1; then
          echo "Creating ECS service-linked role..."
          aws iam create-service-linked-role --aws-service-name ecs.amazonaws.com
        else
          echo "ECS service-linked role already exists"
        fi
        
        if ! aws iam get-role --role-name AWSServiceRoleForElasticLoadBalancing >/dev/null 2>&1; then
          echo "Creating ELB service-linked role..."
          aws iam create-service-linked-role --aws-service-name elasticloadbalancing.amazonaws.com
        else
          echo "ELB service-linked role already exists"
        fi
        
        # Use existing ECS cluster
        CLUSTER_NAME="flight-tracker-cluster"
        echo "Using existing ECS cluster: $CLUSTER_NAME"
        
        # Wait for cluster to be ready
        sleep 15
        
        # Create execution role for ECS tasks with better error handling
        cat > task-execution-role-policy.json << 'EOF'
        {
          "Version": "2012-10-17",
          "Statement": [
            {
              "Effect": "Allow",
              "Principal": {
                "Service": "ecs-tasks.amazonaws.com"
              },
              "Action": "sts:AssumeRole"
            }
          ]
        }
        EOF
        
        # Use existing task execution role
        TASK_ROLE_NAME="flight-tracker-task-execution-role"
        echo "Using existing task execution role: $TASK_ROLE_NAME"
        
        # Wait for role to be fully ready (AWS IAM propagation can take time)
        sleep 15
        
        # Use Redis endpoint from environment (fallback to localhost)
        source deployment_vars.env
        echo "Redis endpoint: $REDIS_ENDPOINT"
        
        # Ensure environment variables are available for task definition
        export AWS_ACCOUNT_ID="${{ env.AWS_ACCOUNT_ID }}"
        export AWS_REGION="${{ env.AWS_REGION }}"
        echo "Using Account ID: $AWS_ACCOUNT_ID in Region: $AWS_REGION"
        
        # Get existing role ARN
        ROLE_ARN=$(aws iam get-role --role-name $TASK_ROLE_NAME --query 'Role.Arn' --output text)
        echo "Using task execution role ARN: $ROLE_ARN"
        
        # Verify role exists
        if [ "$ROLE_ARN" = "None" ] || [ -z "$ROLE_ARN" ]; then
          echo "ERROR: Role does not exist or is not accessible"
          exit 1
        fi
        
        # Create task definition with updated application image
        cat > task-definition.json << EOF
        {
          "family": "flight-tracker-backend",
          "networkMode": "awsvpc",
          "requiresCompatibilities": ["FARGATE"],
          "cpu": "256",
          "memory": "512",
          "executionRoleArn": "${ROLE_ARN}",
          "containerDefinitions": [
            {
              "name": "web-api",
              "image": "$ECR_IMAGE_URI",
              "portMappings": [
                {
                  "containerPort": 80,
                  "protocol": "tcp"
                }
              ],
              "essential": true,
              "logConfiguration": {
                "logDriver": "awslogs",
                "options": {
                  "awslogs-group": "/ecs/flight-tracker",
                  "awslogs-region": "${AWS_REGION}",
                  "awslogs-stream-prefix": "ecs"
                }
              }
            }
          ]
        }
        EOF
        
        # Use existing CloudWatch log group
        LOG_GROUP_NAME="/ecs/flight-tracker"
        echo "Using existing CloudWatch log group: $LOG_GROUP_NAME"
        
        # Debug: Show the generated task definition
        echo "Generated task definition:"
        cat task-definition.json
        
        # Register task definition
        echo "Registering task definition..."
        TASK_DEF_ARN=$(aws ecs register-task-definition --cli-input-json file://task-definition.json --query 'taskDefinition.taskDefinitionArn' --output text)
        
        # Update existing ECS service
        SERVICE_NAME="flight-tracker-backend"
        echo "Updating existing ECS service: $SERVICE_NAME"
        
        # Check service existence
        if aws ecs describe-services --cluster $CLUSTER_NAME --services $SERVICE_NAME --query 'services[0].serviceName' --output text 2>/dev/null | grep -q "$SERVICE_NAME"; then
          echo "Service exists, checking status..."
          echo "Service exists, updating with new task definition..."
          aws ecs update-service \
            --cluster $CLUSTER_NAME \
            --service $SERVICE_NAME \
            --task-definition flight-tracker-backend
        else
          echo "ERROR: Service $SERVICE_NAME not found in cluster $CLUSTER_NAME"
          exit 1
        fi
        
        echo "ECS service deployed. ALB endpoint: http://$ALB_DNS"

    - name: Update CloudFront distribution
      run: |
        # Get CloudFront distribution ID if exists
        DISTRIBUTION_ID=$(aws cloudfront list-distributions \
          --query "DistributionList.Items[?Comment=='ChopperTracker'].Id" \
          --output text 2>/dev/null || echo "")
        
        echo "CloudFront distribution search result: '$DISTRIBUTION_ID'"
        
        if [ ! -z "$DISTRIBUTION_ID" ] && [ "$DISTRIBUTION_ID" != "None" ] && [ "$DISTRIBUTION_ID" != "null" ]; then
          echo "Creating CloudFront invalidation for distribution $DISTRIBUTION_ID"
          aws cloudfront create-invalidation \
            --distribution-id $DISTRIBUTION_ID \
            --paths "/*"
        else
          echo "No CloudFront distribution found (result: '$DISTRIBUTION_ID')"
        fi

    - name: Output deployment URL
      run: |
        echo "Frontend deployed to: http://flight-tracker-web-ui-1750266711.s3-website-${AWS_REGION}.amazonaws.com"
        echo "Backend API available at: http://flight-tracker-alb-790028972.us-east-1.elb.amazonaws.com"
        echo "Note: CloudFront distribution will be created separately if needed"